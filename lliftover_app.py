import streamlit as st
import pandas as pd
import numpy as np
import os
import tempfile
import subprocess

# --- ALL YOUR HELPER FUNCTIONS (create_marker_id, convert_chromosome, etc.) remain the same ---
# ... (keep all your existing functions like create_marker_id, convert_chromosome, create_bed_file, lift_over_coordinates)

# --- Streamlit App UI ---
st.set_page_config(layout="wide", page_title="Genomic Liftover Tool", page_icon="üß¨")

# --- NEW WELCOME PAGE CONTENT ---
st.title("üß¨ Genomic Coordinate Liftover Tool")
st.markdown("""
Welcome! This application helps you convert genomic coordinates (like SNPs or other markers)
from one human genome build to another (e.g., hg19/GRCh37 to hg38/GRCh38 or vice-versa).
It uses the powerful **CrossMap** tool and a **chain file** to perform the liftover.
""")

st.markdown("---") # Visual separator

# How to Use Section
st.header("üöÄ How to Use This Tool")
st.markdown("""
1.  **üìÅ Upload Your Files (in the sidebar on the left):**
    *   **Input Data File:** Your genomic data. This should be a text file (CSV, TSV, TXT), potentially gzipped (`.gz`). It **must** contain columns for chromosome, position, reference allele, and alternate allele.
    *   **Chain File:** A liftover chain file (e.g., `hg19ToHg38.over.chain.gz`). This file defines the mappings between the two genome builds. You can download common chain files from sources like the [UCSC Genome Browser](https://hgdownload.soe.ucsc.edu/goldenPath/hg19/liftOver/) (look for `.over.chain.gz` files).

2.  **‚öôÔ∏è Configure Parameters (in the sidebar):**
    *   **Output File Prefix:** A name for your output files (e.g., `my_data_hg38`).
    *   **Column Names:** Accurately specify the names of the columns in your data file that correspond to:
        *   Chromosome (e.g., `CHR`, `chrom`, `Chromosome`)
        *   Base Pair Position (e.g., `BP`, `pos`, `Position`)
        *   Reference Allele (e.g., `REF`, `ref`, `Allele1`)
        *   Alternate Allele (e.g., `ALT`, `alt`, `Allele2`)
    *   **Input File Separator:** Choose how columns are separated in your input file (Comma, Tab, or Space).

3.  **‚ñ∂Ô∏è Run Liftover:**
    *   Click the **"Run Liftover"** button in the sidebar.
    *   The process might take some time, especially for large files. A spinner will indicate progress.

4.  **üì• Download Results:**
    *   Once complete, a download button will appear for your processed file (e.g., `my_data_hg38_lifted_results.csv`).
    *   The output file will include your original data along with new columns for the lifted chromosome (`chrom_lifted`) and position (`pos_lifted`).
""")
st.info("üí° **Tip:** Use the sidebar on the left to upload files and configure your liftover.")

st.markdown("---")

# Informational Expanders
st.header("‚ÑπÔ∏è Learn More")

with st.expander("What is Genomic Liftover?"):
    st.markdown("""
    Genomic liftover (or coordinate lifting) is the process of converting genomic coordinates from one version of a reference genome assembly to another.
    Genome assemblies are updated over time to improve accuracy, fill gaps, and correct errors. This means that the "address" (chromosome and position) of a specific gene or variant can change between assemblies.

    **Why is it necessary?**
    *   You might have older data annotated on hg19 but need to compare it with newer resources based on hg38.
    *   Integrating datasets from different studies that used different reference genomes.
    *   Ensuring consistency when using various bioinformatics tools and databases.
    """)

with st.expander("Understanding Chain Files"):
    st.markdown("""
    A **chain file** is a crucial component for liftover. It essentially contains a detailed map of how segments of one genome assembly align to another.
    *   These files are typically generated by aligning two genome assemblies (e.g., hg19 and hg38) to each other.
    *   They describe blocks of sequence that are conserved between the two assemblies and how their coordinates relate.
    *   Common chain files (e.g., `hg19ToHg38.over.chain.gz`, `hg38ToHg19.over.chain.gz`) can be downloaded from resources like the [UCSC Genome Browser downloads page](https://hgdownload.soe.ucsc.edu/downloads.html).
    *   Make sure you choose the correct chain file for the direction of your conversion (e.g., if your data is hg19 and you want hg38, use an hg19-to-hg38 chain file).
    """)

with st.expander("How `marker_id` is Created and Used"):
    st.markdown("""
    To ensure accurate matching of variants before and after liftover, this tool creates a unique `marker_id` for each row in your input data.
    *   The ID is formatted as: `chr<Chromosome>:<Position>:<Allele1>:<Allele2>`
    *   The alleles (Reference and Alternate) are **sorted alphabetically** before being included in the ID. This means `chr1:100:A:T` is the same as `chr1:100:T:A`. This is important because the ref/alt orientation can sometimes be ambiguous or flipped.
    *   This `marker_id` is used to:
        1.  Label entries in the temporary BED file fed to CrossMap.
        2.  Reliably merge the liftover results (new coordinates) back with your original data.
    """)

with st.expander("About CrossMap"):
    st.markdown("""
    This tool uses **CrossMap** ([http://crossmap.sourceforge.net/](http://crossmap.sourceforge.net/)) in the background.
    CrossMap is a versatile command-line program for convenient conversion of genome coordinates and genome annotation files between different genome assemblies.
    It supports various file formats, including BED, GFF/GTF, VCF, and SAM/BAM.
    This application specifically uses its `CrossMap bed` functionality.
    """)

st.markdown("---")
st.markdown("Application developed to simplify genomic coordinate liftover. Ensure `CrossMap` is correctly installed if running locally, or that dependencies are met on Streamlit Community Cloud.")
st.markdown("Navigate to the sidebar to begin! ‚¨ÖÔ∏è")


# --- SIDEBAR CONTENT (remains mostly the same) ---
st.sidebar.header("Liftover Configuration") # Changed title slightly

# File Uploads
st.sidebar.subheader("1. Upload Files") # Used subheader for better structure
uploaded_data_file = st.sidebar.file_uploader("Upload your input data file (e.g., .tsv.gz, .csv)", type=['csv', 'tsv', 'gz', 'txt'])
uploaded_chain_file = st.sidebar.file_uploader("Upload your chain file (e.g., .chain.gz)", type=['chain', 'gz'])

# Configuration
st.sidebar.subheader("2. Configure Parameters") # Used subheader
output_prefix = st.sidebar.text_input("Output file prefix", "liftover_results")

# Dynamically get column names from uploaded data file if available
col_names = []
temp_data_for_cols = None
if uploaded_data_file:
    # ... (your existing column name detection logic)
    try:
        # Read only a few lines to get headers
        # Make sure to handle potential errors if file is not readable as expected
        current_pos = uploaded_data_file.tell()
        if uploaded_data_file.name.endswith('.gz'):
            temp_data_for_cols = pd.read_csv(uploaded_data_file, sep=None, engine='python', compression='gzip', nrows=5, on_bad_lines='skip')
        else:
            temp_data_for_cols = pd.read_csv(uploaded_data_file, sep=None, engine='python', nrows=5, on_bad_lines='skip')
        uploaded_data_file.seek(current_pos) # Reset file pointer
        if temp_data_for_cols is not None and not temp_data_for_cols.empty:
            col_names = temp_data_for_cols.columns.tolist()
        else:
            st.sidebar.caption("Could not auto-detect columns. Please enter manually.")
    except Exception as e:
        st.sidebar.warning(f"Could not pre-read column names: {e}")
        uploaded_data_file.seek(0) # Reset file pointer in case of error

# Using st.selectbox for column names allows for easier selection if col_names is populated
chrom_col_default_index = 0
if col_names:
    for i, col in enumerate(col_names):
        if col.lower() in ['chrom', 'chr', 'chromosome']:
            chrom_col_default_index = i
            break
chrom_col = st.sidebar.selectbox("Chromosome column name", col_names if col_names else ["Enter Manually"], index=chrom_col_default_index if col_names else 0)
if not col_names: chrom_col = st.sidebar.text_input("Chromosome column (if not in list)", "chrom")


pos_col_default_index = 0
if col_names:
    for i, col in enumerate(col_names):
        if col.lower() in ['pos', 'bp', 'position', 'variantpos']:
            pos_col_default_index = i
            break
pos_col = st.sidebar.selectbox("Base pair position column name", col_names if col_names else ["Enter Manually"], index=pos_col_default_index if col_names else 0)
if not col_names: pos_col = st.sidebar.text_input("Position column (if not in list)", "pos")


ref_col_default_index = 0
if col_names:
    for i, col in enumerate(col_names):
        if col.lower() in ['ref', 'reference', 'allele1', 'refallele']:
            ref_col_default_index = i
            break
ref_col = st.sidebar.selectbox("Reference allele column name", col_names if col_names else ["Enter Manually"], index=ref_col_default_index if col_names else 0)
if not col_names: ref_col = st.sidebar.text_input("Reference allele column (if not in list)", "ref")


alt_col_default_index = 0
if col_names:
    for i, col in enumerate(col_names):
        if col.lower() in ['alt', 'alternate', 'allele2', 'altallele']:
            alt_col_default_index = i
            break
alt_col = st.sidebar.selectbox("Alternate allele column name", col_names if col_names else ["Enter Manually"], index=alt_col_default_index if col_names else 0)
if not col_names: alt_col = st.sidebar.text_input("Alternate allele column (if not in list)", "alt")


input_sep_options = {',': 'Comma (,)', '\t': 'Tab (\\t)', ' ': 'Space ( )'}
input_sep_display = st.sidebar.selectbox("Input file separator", options=list(input_sep_options.keys()), format_func=lambda x: input_sep_options[x])

st.sidebar.subheader("3. Run Liftover") # Used subheader
if st.sidebar.button("üöÄ Run Liftover", key="run_liftover_button"): # Added key for uniqueness
    if uploaded_data_file and uploaded_chain_file and chrom_col and pos_col and ref_col and alt_col and output_prefix:
        # ... (your existing "Run Liftover" logic)
        with st.spinner("Processing... This may take a while for large files."):
            with tempfile.TemporaryDirectory() as tmpdir:
                data_file_path = os.path.join(tmpdir, uploaded_data_file.name)
                with open(data_file_path, "wb") as f:
                    f.write(uploaded_data_file.getbuffer())

                chain_file_path = os.path.join(tmpdir, uploaded_chain_file.name)
                with open(chain_file_path, "wb") as f:
                    f.write(uploaded_chain_file.getbuffer())

                temp_output_prefix = os.path.join(tmpdir, output_prefix)
                output_compression_type = 'gzip' if uploaded_data_file.name.endswith('.gz') else None

                final_output_csv_path = lift_over_coordinates( # This function is defined elsewhere
                    data_path=data_file_path,
                    chain_path=chain_file_path,
                    output_prefix=temp_output_prefix,
                    chrom_col=chrom_col,
                    pos_col=pos_col,
                    ref_col=ref_col,
                    alt_col=alt_col,
                    sep=input_sep_display,
                    compression=output_compression_type
                )

                if final_output_csv_path and os.path.exists(final_output_csv_path):
                    st.success("Liftover process completed!")
                    with open(final_output_csv_path, "rb") as fp:
                        download_filename = f"{output_prefix}_lifted_results.csv"
                        if output_compression_type == 'gzip':
                            download_filename += ".gz"
                        st.download_button(
                            label="üì• Download Lifted Data",
                            data=fp,
                            file_name=download_filename,
                            mime="text/csv" if output_compression_type is None else "application/gzip"
                        )
                    try:
                        # Determine separator for reading preview correctly
                        preview_sep = ',' if input_sep_display == ',' else '\t' # Simplified, might need adjustment for space
                        if input_sep_display == ' ': preview_sep = r'\s+'

                        preview_df = pd.read_csv(final_output_csv_path,
                                                 sep=preview_sep,
                                                 compression=output_compression_type,
                                                 nrows=100) # Limit preview size
                        st.markdown("### Preview of Lifted Data (first 100 rows):")
                        st.dataframe(preview_df)

                        unmapped_file_expected_path = f"{temp_output_prefix}_crossmap_output.bed.unmap"
                        if os.path.exists(unmapped_file_expected_path) and os.path.getsize(unmapped_file_expected_path) > 0:
                            st.info(f"An unmapped regions file was also generated by CrossMap: "
                                    f"'{os.path.basename(unmapped_file_expected_path)}'. "
                                    f"This file contains regions that could not be lifted over and is stored temporarily with other intermediate files.")
                        elif os.path.exists(unmapped_file_expected_path):
                             st.info("Unmapped regions file was generated by CrossMap but is empty.")

                    except Exception as e:
                        st.warning(f"Could not display preview of results: {e}")
                elif final_output_csv_path:
                     st.error(f"Output file {final_output_csv_path} was expected but not found. Please check logs.")
                else:
                    st.error("Liftover process failed. Please check the error messages above or contact support.")
    else:
        st.sidebar.error("‚ö†Ô∏è Please fill in all fields and upload necessary files before running.")

# Footer or additional info
st.markdown("---")
st.caption("Built with Streamlit | Uses CrossMap for liftover operations.")
st.caption("by Alok Singh - 2025")

st.markdown("If you encounter any issues, please report them on the GitHub repository. https://github.com/as-uh/genomic-liftover-app.git")
st.markdown("**Disclaimer:** This tool is provided as-is. Ensure you have the necessary permissions to use the data and tools.")
st.markdown("**Note:** This app is designed for educational and research purposes. "
             "Always validate results with appropriate bioinformatics pipelines.")
```
# End of the Streamlit app code
```